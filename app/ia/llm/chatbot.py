from langchain_community.utilities import SQLDatabase
from langchain_groq import ChatGroq
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnablePassthrough
from langchain_core.prompts import ChatPromptTemplate
from dotenv import load_dotenv, find_dotenv
import os

_ = load_dotenv(find_dotenv())

db_path = "instance/user_data/user_1.sqlite"
assert os.path.exists(db_path), f"Banco não encontrado: {db_path}"

db = SQLDatabase.from_uri(
    f"sqlite:///{db_path}"  
)
# Teste consulta SQL direta
#print(db.run("SELECT * FROM despesas LIMIT 1"))

# Define a prompt template for SQL queries
# This template will be used to format the question and schema into a SQL query
# The schema is dynamically fetched from the database
# The question is provided by the user at runtime
# The template should be defined outside of the function to avoid reloading it unnecessarily
# If the template is passed as an argument, it should be a properly formatted string
template = """
Com base no esquema de tabela abaixo, escreva uma consulta SQL que responda à pergunta do usuário.
{schema}

Pergunta: {question}
Somente a consulta SQL, sem explicações adicionais e sem formatações. 
"""

prompt = ChatPromptTemplate.from_template(template=template)


def get_schame(_):
    return db.get_table_info()


llm = ChatGroq(model="llama-3.1-8b-instant")

sql_chain = (
    RunnablePassthrough.assign(schema=get_schame)
    | prompt 
    | llm.bind(stop="\nSQL Result:")
    | StrOutputParser()
)



# Define a template for the chat interaction
# This template will be used to format the question, schema, and SQL query into a chat
# The schema is dynamically fetched from the database
# The question is provided by the user at runtime
# The SQL query is generated by the SQL chain
# The response is the result of the SQL query execution
# The template should be defined outside of the function to avoid reloading it unnecessarily
# If the template is passed as an argument, it should be a properly formatted string
template_chat = """
Você é um assistente de IA especializado em responder perguntas sobre dados financeiros.
O usuário fará perguntas sobre suas despesas e receitas, e você deve responder com base nos dados disponíveis.
Não forneça as queries que foi enviada para você executar, apenas a resposta amigável com explicações que achar pertinentes.
Use o seguinte esquema de tabela para entender os dados disponíveis:
{schema}

Pergunta: {question}
SQL query: {sql_query} 
Resposta SQL: {response}
"""

prompt_chat = ChatPromptTemplate.from_template(template=template_chat)


def clean_sql_query(query):
    if query is None:
        return ""
    query = query.strip()
    if query.startswith("```sql"):
        query = query[len("```sql"):].strip()
    if query.endswith("```"):
        query = query[:-3].strip()
    return query

def run_query(query):
    query = clean_sql_query(query)
    return db.run(query)

full_chain = (
    RunnablePassthrough.assign(sql_query=sql_chain).assign(
        schema=get_schame,
        response=lambda vars: run_query(vars["sql_query"]) if "sql_query" in vars else None
    )
    | prompt_chat
    | llm
    | StrOutputParser()
)

# if __name__ == "__main__":
#     print("Chatbot financeiro iniciado. Digite sua pergunta ou 'sair' para encerrar.")
#     while True:
#         question = input("\nPergunta: ")
#         if question.lower() in ["sair", "exit", "quit"]:
#             print("Encerrando chatbot.")
#             break
#         try:
#             result = full_chain.invoke({"question": question})
#             print("\nResposta:", result)
#         except Exception as e:
#             print("\nErro:", e)